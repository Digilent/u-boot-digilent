/* SPDX-License-Identifier: GPL-2.0 */
/*
 * Xilinx Zynq MPSoC Firmware driver
 *
 * Copyright (C) 2018-2019 Xilinx, Inc.
 */

#ifndef _ZYNQMP_FIRMWARE_H_
#define _ZYNQMP_FIRMWARE_H_

enum pm_api_id {
	PM_GET_API_VERSION = 1,
	PM_SET_CONFIGURATION,
	PM_GET_NODE_STATUS,
	PM_GET_OPERATING_CHARACTERISTIC,
	PM_REGISTER_NOTIFIER,
	PM_REQUEST_SUSPEND,
	PM_SELF_SUSPEND,
	PM_FORCE_POWERDOWN,
	PM_ABORT_SUSPEND,
	PM_REQUEST_WAKEUP,
	PM_SET_WAKEUP_SOURCE,
	PM_SYSTEM_SHUTDOWN,
	PM_REQUEST_NODE,
	PM_RELEASE_NODE,
	PM_SET_REQUIREMENT,
	PM_SET_MAX_LATENCY,
	PM_RESET_ASSERT,
	PM_RESET_GET_STATUS,
	PM_MMIO_WRITE,
	PM_MMIO_READ,
	PM_PM_INIT_FINALIZE,
	PM_FPGA_LOAD,
	PM_FPGA_GET_STATUS,
	PM_GET_CHIPID,
	PM_SECURE_SHA = 26,
	PM_SECURE_RSA,
	PM_PINCTRL_REQUEST,
	PM_PINCTRL_RELEASE,
	PM_PINCTRL_GET_FUNCTION,
	PM_PINCTRL_SET_FUNCTION,
	PM_PINCTRL_CONFIG_PARAM_GET,
	PM_PINCTRL_CONFIG_PARAM_SET,
	PM_IOCTL,
	PM_QUERY_DATA,
	PM_CLOCK_ENABLE,
	PM_CLOCK_DISABLE,
	PM_CLOCK_GETSTATE,
	PM_CLOCK_SETDIVIDER,
	PM_CLOCK_GETDIVIDER,
	PM_CLOCK_SETRATE,
	PM_CLOCK_GETRATE,
	PM_CLOCK_SETPARENT,
	PM_CLOCK_GETPARENT,
	PM_SECURE_IMAGE,
	PM_FPGA_READ = 46,
	PM_SECURE_AES,
	PM_CLOCK_PLL_GETPARAM = 49,
	PM_REGISTER_ACCESS = 52,
	PM_EFUSE_ACCESS,
	PM_FEATURE_CHECK = 63,
	PM_API_MAX,
};

enum pm_node_id {
	NODE_UNKNOWN = 0,
	NODE_APU = 1,
	NODE_APU_0 = 2,
	NODE_APU_1 = 3,
	NODE_APU_2 = 4,
	NODE_APU_3 = 5,
	NODE_RPU = 6,
	NODE_RPU_0 = 7,
	NODE_RPU_1 = 8,
	NODE_PLD = 9,
	NODE_FPD = 10,
	NODE_OCM_BANK_0 = 11,
	NODE_OCM_BANK_1 = 12,
	NODE_OCM_BANK_2 = 13,
	NODE_OCM_BANK_3 = 14,
	NODE_TCM_0_A = 15,
	NODE_TCM_0_B = 16,
	NODE_TCM_1_A = 17,
	NODE_TCM_1_B = 18,
	NODE_L2 = 19,
	NODE_GPU_PP_0 = 20,
	NODE_GPU_PP_1 = 21,
	NODE_USB_0 = 22,
	NODE_USB_1 = 23,
	NODE_TTC_0 = 24,
	NODE_TTC_1 = 25,
	NODE_TTC_2 = 26,
	NODE_TTC_3 = 27,
	NODE_SATA = 28,
	NODE_ETH_0 = 29,
	NODE_ETH_1 = 30,
	NODE_ETH_2 = 31,
	NODE_ETH_3 = 32,
	NODE_UART_0 = 33,
	NODE_UART_1 = 34,
	NODE_SPI_0 = 35,
	NODE_SPI_1 = 36,
	NODE_I2C_0 = 37,
	NODE_I2C_1 = 38,
	NODE_SD_0 = 39,
	NODE_SD_1 = 40,
	NODE_DP = 41,
	NODE_GDMA = 42,
	NODE_ADMA = 43,
	NODE_NAND = 44,
	NODE_QSPI = 45,
	NODE_GPIO = 46,
	NODE_CAN_0 = 47,
	NODE_CAN_1 = 48,
	NODE_EXTERN = 49,
	NODE_APLL = 50,
	NODE_VPLL = 51,
	NODE_DPLL = 52,
	NODE_RPLL = 53,
	NODE_IOPLL = 54,
	NODE_DDR = 55,
	NODE_IPI_APU = 56,
	NODE_IPI_RPU_0 = 57,
	NODE_GPU = 58,
	NODE_PCIE = 59,
	NODE_PCAP = 60,
	NODE_RTC = 61,
	NODE_LPD = 62,
	NODE_VCU = 63,
	NODE_IPI_RPU_1 = 64,
	NODE_IPI_PL_0 = 65,
	NODE_IPI_PL_1 = 66,
	NODE_IPI_PL_2 = 67,
	NODE_IPI_PL_3 = 68,
	NODE_PL = 69,
	NODE_GEM_TSU = 70,
	NODE_SWDT_0 = 71,
	NODE_SWDT_1 = 72,
	NODE_CSU = 73,
	NODE_PJTAG = 74,
	NODE_TRACE = 75,
	NODE_TESTSCAN = 76,
	NODE_PMU = 77,
	NODE_MAX = 78,
};

enum tap_delay_type {
	PM_TAPDELAY_INPUT = 0,
	PM_TAPDELAY_OUTPUT = 1,
};

enum dll_reset_type {
	PM_DLL_RESET_ASSERT = 0,
	PM_DLL_RESET_RELEASE = 1,
	PM_DLL_RESET_PULSE = 2,
};

enum pm_query_id {
	PM_QID_INVALID = 0,
	PM_QID_CLOCK_GET_NAME = 1,
	PM_QID_CLOCK_GET_TOPOLOGY = 2,
	PM_QID_CLOCK_GET_FIXEDFACTOR_PARAMS = 3,
	PM_QID_CLOCK_GET_PARENTS = 4,
	PM_QID_CLOCK_GET_ATTRIBUTES = 5,
	PM_QID_PINCTRL_GET_NUM_PINS = 6,
	PM_QID_PINCTRL_GET_NUM_FUNCTIONS = 7,
	PM_QID_PINCTRL_GET_NUM_FUNCTION_GROUPS = 8,
	PM_QID_PINCTRL_GET_FUNCTION_NAME = 9,
	PM_QID_PINCTRL_GET_FUNCTION_GROUPS = 10,
	PM_QID_PINCTRL_GET_PIN_GROUPS = 11,
	PM_QID_CLOCK_GET_NUM_CLOCKS = 12,
	PM_QID_CLOCK_GET_MAX_DIVISOR = 13,
};

enum pm_pinctrl_config_param {
	PM_PINCTRL_CONFIG_SLEW_RATE,
	PM_PINCTRL_CONFIG_BIAS_STATUS,
	PM_PINCTRL_CONFIG_PULL_CTRL,
	PM_PINCTRL_CONFIG_SCHMITT_CMOS,
	PM_PINCTRL_CONFIG_DRIVE_STRENGTH,
	PM_PINCTRL_CONFIG_VOLTAGE_STATUS,
	PM_PINCTRL_CONFIG_TRI_STATE,
	PM_PINCTRL_CONFIG_MAX,
};

enum pm_pinctrl_slew_rate {
	PM_PINCTRL_SLEW_RATE_FAST,
	PM_PINCTRL_SLEW_RATE_SLOW,
};

enum pm_pinctrl_bias_status {
	PM_PINCTRL_BIAS_DISABLE,
	PM_PINCTRL_BIAS_ENABLE,
};

enum pm_pinctrl_pull_ctrl {
	PM_PINCTRL_BIAS_PULL_DOWN,
	PM_PINCTRL_BIAS_PULL_UP,
};

enum pm_pinctrl_schmitt_cmos {
	PM_PINCTRL_INPUT_TYPE_CMOS,
	PM_PINCTRL_INPUT_TYPE_SCHMITT,
};

enum pm_pinctrl_drive_strength {
	PM_PINCTRL_DRIVE_STRENGTH_2MA,
	PM_PINCTRL_DRIVE_STRENGTH_4MA,
	PM_PINCTRL_DRIVE_STRENGTH_8MA,
	PM_PINCTRL_DRIVE_STRENGTH_12MA,
};

enum pm_pinctrl_tri_state {
	PM_PINCTRL_TRI_STATE_DISABLE = 0,
	PM_PINCTRL_TRI_STATE_ENABLE,
};

enum pm_ioctl_id {
	IOCTL_GET_RPU_OPER_MODE,
	IOCTL_SET_RPU_OPER_MODE,
	IOCTL_RPU_BOOT_ADDR_CONFIG,
	IOCTL_TCM_COMB_CONFIG,
	IOCTL_SET_TAPDELAY_BYPASS,
	IOCTL_SET_SGMII_MODE,
	IOCTL_SD_DLL_RESET,
	IOCTL_SET_SD_TAPDELAY,
	IOCTL_SET_PLL_FRAC_MODE,
	IOCTL_GET_PLL_FRAC_MODE,
	IOCTL_SET_PLL_FRAC_DATA,
	IOCTL_GET_PLL_FRAC_DATA,
	IOCTL_WRITE_GGS,
	IOCTL_READ_GGS,
	IOCTL_WRITE_PGGS,
	IOCTL_READ_PGGS,
	/* IOCTL for ULPI reset */
	IOCTL_ULPI_RESET,
	/* Set healthy bit value*/
	IOCTL_SET_BOOT_HEALTH_STATUS,
	IOCTL_AFI,
	/* Probe counter read/write */
	IOCTL_PROBE_COUNTER_READ,
	IOCTL_PROBE_COUNTER_WRITE,
	IOCTL_OSPI_MUX_SELECT,
	/* IOCTL for USB power request */
	IOCTL_USB_SET_STATE,
	/* IOCTL to get last reset reason */
	IOCTL_GET_LAST_RESET_REASON,
	/* AIE ISR Clear */
	IOCTL_AIE_ISR_CLEAR,
};

enum ospi_mux_select_type {
	PM_OSPI_MUX_SEL_DMA,
	PM_OSPI_MUX_SEL_LINEAR,
	PM_OSPI_MUX_GET_MODE,
};

enum zynqmp_pm_request_ack {
	PM_REQUEST_ACK_NO = 1,
	PM_REQUEST_ACK_BLOCKING,
	PM_REQUEST_ACK_NON_BLOCKING,
};

#define PM_SIP_SVC      0xc2000000

#define ZYNQMP_PM_VERSION_MAJOR         1
#define ZYNQMP_PM_VERSION_MINOR         0
#define ZYNQMP_PM_VERSION_MAJOR_SHIFT   16
#define ZYNQMP_PM_VERSION_MINOR_MASK    0xFFFF

#define ZYNQMP_PM_VERSION       \
	((ZYNQMP_PM_VERSION_MAJOR << ZYNQMP_PM_VERSION_MAJOR_SHIFT) | \
	 ZYNQMP_PM_VERSION_MINOR)

#define ZYNQMP_PM_VERSION_INVALID       ~0

#define PMUFW_V1_0      ((1 << ZYNQMP_PM_VERSION_MAJOR_SHIFT) | 0)

#define PMIO_NODE_ID_BASE		0x1410801B
#define DEV_OSPI			0x1822402a
#define PM_CAPABILITY_ACCESS		0x1
#define PM_MAX_QOS			100

/*
 * Return payload size
 * Not every firmware call expects the same amount of return bytes, however the
 * firmware driver always copies 5 bytes from RX buffer to the ret_payload
 * buffer. Therefore allocating with this defined value is recommended to avoid
 * overflows.
 */
#define PAYLOAD_ARG_CNT	5U

unsigned int zynqmp_firmware_version(void);
void zynqmp_pmufw_load_config_object(const void *cfg_obj, size_t size);
int xilinx_pm_request(u32 api_id, u32 arg0, u32 arg1, u32 arg2,
		      u32 arg3, u32 *ret_payload);

#endif /* _ZYNQMP_FIRMWARE_H_ */
